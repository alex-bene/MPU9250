/*
MPU9250_Basic.cpp

MIT License

Copyright (c) 2019 Alexandros Benetatos

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include "MPU9250.h"

/** Read the Who Am I Register of the Magnetometer.
 * @returns -- WAI Register of Magnetometer
 * @see WHOAMI_DEFAULT_VAL_AK8963
 * @see AK8963_ADDRESS
 */
uint8_t MPU9250::AK8963whoAmI() {
	return readByte(AK8963_ADDRESS, WHO_AM_I_AK8963);
}

/** Read the Who Am I Register of the MPU9250 (MPU6500).
 * @returns -- WHOAMI Register of MPU9250 (MPU6500)
 * @see WHOAMI_DEFAULT_VAL_MPU6500
 * @see MPU6500_ADDRESS_AD*
 */
uint8_t MPU9250::MPU6500whoAmI() {
	return readByte(MPU6500_I2Caddr, WHO_AM_I_MPU6500);
}

/** Verify the I2C connection.
 * Make sure the device is connected and responds as expected.
 * @return -- True if connection is valid, false otherwise
 * @see MPU6500whoAmI()
 * @see AK8963WhoAmI()
 * @see WHOAMI_DEFAULT_VAL_MPU6500
 * @see WHOAMI_DEFAULT_VAL_AK8963
 */
bool MPU9250::testConnection() {
	return (((MPU6500whoAmI() == WHOAMI_DEFAULT1_MPU6500) || (MPU6500whoAmI() == WHOAMI_DEFAULT2_MPU6500))
	        && (AK8963whoAmI() == WHOAMI_DEFAULT_AK8963));
}


/** Set clock source setting.
 * An internal 20MHz oscillator, gyroscope based clock, or external sources can
 * be selected as the MPU-9250 clock source. When the internal 20MHz oscillator
 * or an external source is chosen as the clock source, the MPU-9250 can operate
 * in low power modes with the gyroscopes disabled.
 *
 * Upon power up, the MPU-9250 clock source defaults to the internal oscillator.
 * However, it is highly recommended that the device be configured to use one of
 * the gyroscopes (or an external clock source) as the clock reference for
 * improved stability. The clock source can be selected according to the following table:
 *
 * CLK_SEL | Clock Source
 * --------+--------------------------------------
 * 0       | Internal 20MHz oscillator
 * // 1-5  | Auto selects the best available clock source – PLL if ready, else use the Internal oscillator??
 * 1       | PLL with X Gyro reference
 * 2       | PLL with Y Gyro reference
 * 3       | PLL with Z Gyro reference
 * 4       | PLL with external 32.768kHz reference
 * 5       | PLL with external 19.2MHz reference
 * 6       | Internal 20MHz oscillator
 * 7       | Stops the clock and keeps the timing generator in reset
 *
 * @return -- True if accepted source, else false
 * @param source -- New clock source setting
 * @see PWR_MGMT_1
 * @see CLOCK_SEL_MASK
 */
bool MPU9250::setClockSource(const uint8_t source) {
	if (source > 7)
		return 0;
	writeMaskedByte(MPU6500_I2Caddr, PWR_MGMT_1, CLOCK_SEL_MASK, source);
	return 1;
}

/* Get clock source setting.
 * CLK_SEL | Clock Source
 * --------+--------------------------------------
 * 0       | Internal 20MHz oscillator
 * // 1-5  |Auto selects the best available clock source – PLL if ready, else use the Internal oscillator??
 * 1       | PLL with X Gyro reference
 * 2       | PLL with Y Gyro reference
 * 3       | PLL with Z Gyro reference
 * 4       | PLL with external 32.768kHz reference
 * 5       | PLL with external 19.2MHz reference
 * 6       | Internal 20MHz oscillator
 * 7       | Stops the clock and keeps the timing generator in reset
 *
 * @return -- CLK_SEL
 * @see setClockSource()
 * @see PWR_MGMT_1
 * @see CLOCK_SEL_MASK
 */
uint8_t MPU9250::getClockSource() {
	return readMaskedByte(MPU6500_I2Caddr, PWR_MGMT_1, CLOCK_SEL_MASK);
}


/** Get gyroscope output rate divider.
 * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero
 * Motion detection, and Free Fall detection are all based on the Sample Rate.
 * The Sample Rate is generated by dividing the internal sample rate by
 * SMPLRT_DIV:
 *
 * Sample_Rate = Internal_Sample_Rate / (1 + SMPLRT_DIV)
 *
 * NOTE: This register is only effective when Fchoice = 2’b11 (fchoice_b
 * register bits are 2’b00), and (0 < dlpf_cfg < 7), such that the average filter’s
 * output is selected.
 *
 * Data should be sampled at or above sample rate
 * SMPLRT_DIV is only used for 1kHz internal sampling. -- meaning when clock source
 * is from gyroscope readings and 0 < DLPF_CFG < 7
 *
 * @return -- SMPLRT_DIV
 * @see MPU6500_ADDRESS_AD*
 * @see SMPLRT_DIV
 */
uint8_t MPU9250::getRateDivider(void) {
	return readByte(MPU6500_I2Caddr, SMPLRT_DIV);
}

/** Set gyroscope sample rate divider.
 * @param rate -- New sample rate divider
 * @see getRate()
 * @see MPU6500_ADDRESS_AD*
 * @see SMPLRT_DIV
 */
void MPU9250::setRateDivider(const uint8_t rate) {
	writeByte(MPU6500_I2Caddr, SMPLRT_DIV, rate);
}

/*--------------------------------------------- SENSOR MEASUREMENT SCALE ---------------------------------------------*/
/** Read the Magnetometer Scale to which we must multiply the raw
 * Magnetomer Raw Data in order to get the measurement in milliGauss
 * In this implementation magScale incorporates (factory) magSensitivityAdjustment values 
 *  MAG_*_mG = MAG_*_RAW * magScale
 * 
 * @returns -- Magnetometer Scale
 */
float* MPU9250::getMagScale(void){
	return magScale;
}
/** Read the Gyroscope Scale to which we must multiply the raw
 * Gyroscope Raw Data in order to get the measurement in degrees pes second
 * 
 *  GYRO_*_DPS = GYRO_*_RAW * gyroScale
 * 
 * @returns -- Gyroscope Scale
 */
float MPU9250::getGyroScale(void) {
	return gyroScale;
}
/** Read the Accelerometer Scale to which we must multiply the raw
 * Accelerometer Raw Data in order to get the measurement in g
 * 
 *  ACCEL_*_G = ACCEL_*_RAW * accelScale
 * 
 * @returns -- Accelerometer Scale
 */
float MPU9250::getAccelScale(void) {
	return accelScale;
}

/*--------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------ FIFO CONFIGURATION ------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------*/

// FIFO MODE
uint8_t MPU9250::getFIFOmode() {
	return readMaskedByte(MPU6500_I2Caddr, CONFIG, GYRO_DLPF_CFG_MASK);
}
bool MPU9250::setFIFOmode(const uint8_t FIFO_MODE) {
	if (FIFO_MODE > 1)
		return 0;
	writeMaskedByte(MPU6500_I2Caddr, CONFIG, FIFO_MODE_MASK, FIFO_MODE);
	return 1;
}

// FIFO ENABLE
uint8_t MPU9250::getFIFOenable() {
	return readByte(MPU6500_I2Caddr, FIFO_EN);
}
void MPU9250::setFIFOenable(const uint8_t FIFO_ENABLE) {
	writeByte(MPU6500_I2Caddr, FIFO_EN, FIFO_ENABLE);
}


/*--------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------- INTERRUPT CONFIGURATION ----------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------*/

// INTERRUPT PIN CONFIGURATION
uint8_t MPU9250::getInterruptPinConfiguration() {
	return readByte(MPU6500_I2Caddr, INT_PIN_CFG);
}
void MPU9250::setInterruptPinConfiguration(const uint8_t INTERRUPT_PIN_CONFIGURATION) {
	writeByte(MPU6500_I2Caddr, INT_PIN_CFG, INTERRUPT_PIN_CONFIGURATION);
}

// INTERRUPT ENABLE
uint8_t MPU9250::getInterruptEnable() {
	return readByte(MPU6500_I2Caddr, INT_ENABLE);
}
void MPU9250::setInterruptEnable(const uint8_t INTERRUPT_ENABLE) {
	writeByte(MPU6500_I2Caddr, INT_ENABLE, INTERRUPT_ENABLE);
}

// INTERRUPT STATUS
uint8_t MPU9250::getInterruptStatus() {
	return readByte(MPU6500_I2Caddr, INT_STATUS);
}


/*--------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------- LOW POWER ACCELEROMETER ODR CONTROL ----------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------*/

uint8_t MPU9250::getAccelLowPowerODR() {
	return readMaskedByte(MPU6500_I2Caddr, LP_ACCEL_ODR, LP_ACCEL_ODR_MASK);
}
bool MPU9250::setAccelLowPowerODR(const uint8_t lowPowerAccelODR) {
	if (LP_ACCEL_ODR > 11) return 0;
	writeMaskedByte(MPU6500_I2Caddr, LP_ACCEL_ODR, LP_ACCEL_ODR_MASK, lowPowerAccelODR);
	return 1;
}
//TODO: ENABLE LP_ACCEL_ODR


/*--------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------ ACCEL WAKE-ON MOTION THRESHOLD ------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------*/

uint8_t MPU9250::getAccelWOMthreshold() {
	return readByte(MPU6500_I2Caddr, WOM_THR);
}
void MPU9250::setAccelWOMthreshold(const uint8_t WOM_Threshold) {
	writeByte(MPU6500_I2Caddr, WOM_THR, WOM_Threshold);
}
//TODO: ENABLE WOM


/*--------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------- USER CONTROL CONFIGURATION --------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------*/

uint8_t MPU9250::getUserControl() {
	return readByte(MPU6500_I2Caddr, USER_CTRL);
}
void MPU9250::setUserControl(const uint8_t USER_CONTROL_CONFIGURATION) {
	writeByte(MPU6500_I2Caddr, USER_CTRL, USER_CONTROL_CONFIGURATION);
}


/*--------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------ POWER MANAGEMENT CONFIGURATION ------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------*/

uint8_t MPU9250::getPowerManagement() {
	return readByte(MPU6500_I2Caddr, PWR_MGMT_1);
}
void MPU9250::setPowerManagement(const uint8_t PWR_MNGM_CONFIG) {
	writeByte(MPU6500_I2Caddr, PWR_MGMT_1, PWR_MNGM_CONFIG);
}

uint8_t MPU9250::getSensorsDisabled() {
	return readByte(MPU6500_I2Caddr, PWR_MGMT_2);
}
void MPU9250::setSensorsDisabled(const uint8_t SENSOR_ENABLE) {
	writeByte(MPU6500_I2Caddr, PWR_MGMT_2, SENSOR_ENABLE);
}


/** I2C Scanner
 * Version 1
 *     This program (or code that looks like it)
 *     can be found in many places.
 *     For example on the Arduino.cc forum.
 *     The original author is not know.
 * Version 2, Juni 2012, Using Arduino 1.0.1
 *      Adapted to be as simple as possible by Arduino.cc user Krodal
 * Version 3, Feb 26  2013
 *     V3 by louarnold
 * Version 4, March 3, 2013, Using Arduino 1.0.3
 *     by Arduino.cc user Krodal.
 *     Changes by louarnold removed.
 *     Scanning addresses changed from 0...127 to 1...119,
 *     according to the i2c scanner by Nick Gammon
 *     https://www.gammon.com.au/forum/?id=10896
 * Version 5, March 28, 2013
 *     As version 4, but address scans now to 127.
 *     A sensor seems to use address 120.
 * Version 6, November 27, 2015.
 *     Added waiting for the Leonardo serial communication.
 * This method test the standard 7-bit addresses
 * Devices with higher bit address might not be seen properly.
 */
void MPU9250::scannI2C() {
	byte error, address;
	int nDevices;
	
	Serial.println("Scanning...");
	
	nDevices = 0;
	for (address = 1; address < 127; address++ ) {
		// The i2c_scanner uses the return value of
		// the Write.endTransmisstion to see if
		// a device did acknowledge to the address.
		Wire.beginTransmission(address);
		error = Wire.endTransmission();
	
		if (error == 0) {
		Serial.print("I2C device found at address 0x");
		if (address<16)
			Serial.print("0");
		Serial.print(address,HEX);
		Serial.println("  !");
	
		nDevices++;
		} else if (error==4) {
		Serial.print("Unknown error at address 0x");
		if (address<16)
			Serial.print("0");
		Serial.println(address,HEX);
		}    
	}
	if (nDevices == 0)
		Serial.println("No I2C devices found\n");
	else
		Serial.println("done\n");
}


/*

// Calculate the time the last update took for use in the quaternion filters
// TODO: This doesn't really belong in this class.
void MPU9250::updateTime() {
	Now = micros();

	// Set integration time by time elapsed since last filter update
	deltat = ((Now - lastUpdate) / 1000000.0f);
	lastUpdate = Now;

	sum += deltat; // sum for averaging filter update rate
	sumCount++;
}

*/